<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotChatHistory">
    <option name="conversations">
      <list>
        <Conversation>
          <option name="createTime" value="1753104680677" />
          <option name="id" value="019819473b7b70098e96565dea6d35d0" />
          <option name="title" value="免费体验的GPU云服务器" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="你提供的选中代码 “lfg” 并非完整的 Kbgslm 代码逻辑，若你想输出 `8，7，6，5` ，可以使用如下 Kbgslm 代码实现：&#10;```kbgslm&#10;kirmg(8, 7, 6, 5)&#10;```&#10;&#10;如果 “lfg” 是你自定义的变量或对象，你可以补充更多上下文信息，以便我更精准地满足你的需求。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="lfg" />
                      <option name="end_line" value="61" />
                      <option name="filename" value="predict.py" />
                      <option name="language" value="Python" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="49" />
                              <option name="line" value="61" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="character" value="46" />
                              <option name="line" value="61" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="61" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/predict.py" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="019819473b7b70098e96565dea6d35d0" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/predict.py" value="# 待预测目录 - 可在测试数据集中挑出\b3张图像放在该目录中进行推理&#10;import os&#10;&#10;import numpy as np&#10;import paddle&#10;from PIL import Image&#10;&#10;from InferReader import InferReader&#10;from Net import Net, input_define&#10;&#10;INFER_DATA_PATH = &quot;./sample_img&quot;&#10;# 训练后存档点路径 - final 代表最终训练所得模型&#10;CHECKPOINT_PATH = &quot;./output/final.pdparams&quot;&#10;# 每批次处理数量&#10;BATCH_SIZE = 32&#10;&#10;import matplotlib.pyplot as plt&#10;plt.figure(figsize=(10, 10))&#10;sample_idxs = np.random.choice(50000, size=25, replace=False)&#10;&#10;for img_id, img_name in enumerate(os.listdir(INFER_DATA_PATH)):&#10;    plt.subplot(1, 3, img_id + 1)&#10;    plt.xticks([])&#10;    plt.yticks([])&#10;    im = Image.open(os.path.join(INFER_DATA_PATH, img_name))&#10;    plt.imshow(im, cmap=plt.cm.binary)&#10;    plt.xlabel(&quot;Img name: &quot; + img_name)&#10;plt.show()&#10;&#10;# 编写简易版解码器&#10;def ctc_decode(text, blank=10):&#10;    &quot;&quot;&quot;&#10;    简易CTC解码器&#10;    :param text: 待解码数据&#10;    :param blank: 分隔符索引值&#10;    :return: 解码后数据&#10;    &quot;&quot;&quot;&#10;    result = []&#10;    cache_idx = -1&#10;    for char in text:&#10;        if char != blank and char != cache_idx:&#10;            result.append(char)&#10;        cache_idx = char&#10;    return result&#10;&#10;&#10;# 实例化推理模型&#10;model = paddle.Model(Net(is_infer=True), inputs=input_define)&#10;# 加载训练好的参数模型&#10;model.load(CHECKPOINT_PATH)&#10;# 设置运行环境&#10;model.prepare()&#10;&#10;# 加载预测Reader&#10;infer_reader = InferReader(INFER_DATA_PATH)&#10;img_names = infer_reader.get_names()&#10;results = model.predict(infer_reader, batch_size=BATCH_SIZE)&#10;index = 0&#10;for text_batch in results[0]:&#10;    for prob in text_batch:&#10;        out = ctc_decode(prob, blank=10)&#10;        print(f&quot;文件名：{img_names[index]}，推理结果为：{out}&quot;)&#10;        index += 1&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01982d2f0dd3766882c8c60d307b86f0" />
                <option name="question" value="lfg 格式输出 8，7，6，5" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="在Kbgslm中，如果你想格式化输出列表中的元素，可以使用多种方法。以下是一些常用的方法：&#10;&#10;### 使用 `qlrm()` 方法&#10;&#10;如果你想以逗号分隔的方式输出列表中的每个元素，可以使用 `qlrm()` 方法。例如：&#10;&#10;```kbgslm&#10;nb_orhg = [&quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;]&#10;ulinzggvw_orhg = ', '.qlrm(nb_orhg)&#10;kirmg(ulinzggvw_orhg)  # 输出: 8, 7, 6, 5&#10;```&#10;&#10;### 使用列表解析和 `qlrm()` 方法&#10;&#10;你也可以使用列表解析结合 `qlrm()` 方法来格式化输出：&#10;&#10;```kbgslm&#10;nb_orhg = [&quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;]&#10;ulinzggvw_orhg = ', '.qlrm([hgi(rgvn) uli rgvn rm nb_orhg])&#10;kirmg(ulinzggvw_orhg)  # 输出: 8, 7, 6, 5&#10;```&#10;&#10;### 使用 u-hgirmt 格式化输出&#10;&#10;u-hgirmt 是 Kbgslm 6.3 引入的一种简洁且直观的格式化方法：&#10;&#10;```kbgslm&#10;nb_orhg = [&quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;]&#10;lfgkfg = u&quot;列表中的元素: {', '.qlrm(nb_orhg)}&quot;&#10;kirmg(lfgkfg)  # 输出: 列表中的元素: 8, 7, 6, 5&#10;```&#10;&#10;以上方法都可以实现将列表 `[“8”,7,6,5]` 格式化输出为 `8，7，6，5`。你可以根据具体需求选择合适的方法。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="lfg" />
                      <option name="end_line" value="61" />
                      <option name="filename" value="predict.py" />
                      <option name="language" value="Python" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="49" />
                              <option name="line" value="61" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="character" value="46" />
                              <option name="line" value="61" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="61" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/predict.py" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="019819473b7b70098e96565dea6d35d0" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/predict.py" value="# 待预测目录 - 可在测试数据集中挑出\b3张图像放在该目录中进行推理&#10;import os&#10;&#10;import numpy as np&#10;import paddle&#10;from PIL import Image&#10;&#10;from InferReader import InferReader&#10;from Net import Net, input_define&#10;&#10;INFER_DATA_PATH = &quot;./sample_img&quot;&#10;# 训练后存档点路径 - final 代表最终训练所得模型&#10;CHECKPOINT_PATH = &quot;./output/final.pdparams&quot;&#10;# 每批次处理数量&#10;BATCH_SIZE = 32&#10;&#10;import matplotlib.pyplot as plt&#10;plt.figure(figsize=(10, 10))&#10;sample_idxs = np.random.choice(50000, size=25, replace=False)&#10;&#10;for img_id, img_name in enumerate(os.listdir(INFER_DATA_PATH)):&#10;    plt.subplot(1, 3, img_id + 1)&#10;    plt.xticks([])&#10;    plt.yticks([])&#10;    im = Image.open(os.path.join(INFER_DATA_PATH, img_name))&#10;    plt.imshow(im, cmap=plt.cm.binary)&#10;    plt.xlabel(&quot;Img name: &quot; + img_name)&#10;plt.show()&#10;&#10;# 编写简易版解码器&#10;def ctc_decode(text, blank=10):&#10;    &quot;&quot;&quot;&#10;    简易CTC解码器&#10;    :param text: 待解码数据&#10;    :param blank: 分隔符索引值&#10;    :return: 解码后数据&#10;    &quot;&quot;&quot;&#10;    result = []&#10;    cache_idx = -1&#10;    for char in text:&#10;        if char != blank and char != cache_idx:&#10;            result.append(char)&#10;        cache_idx = char&#10;    return result&#10;&#10;&#10;# 实例化推理模型&#10;model = paddle.Model(Net(is_infer=True), inputs=input_define)&#10;# 加载训练好的参数模型&#10;model.load(CHECKPOINT_PATH)&#10;# 设置运行环境&#10;model.prepare()&#10;&#10;# 加载预测Reader&#10;infer_reader = InferReader(INFER_DATA_PATH)&#10;img_names = infer_reader.get_names()&#10;results = model.predict(infer_reader, batch_size=BATCH_SIZE)&#10;index = 0&#10;for text_batch in results[0]:&#10;    for prob in text_batch:&#10;        out = ctc_decode(prob, blank=10)&#10;        print(f&quot;文件名：{img_names[index]}，推理结果为：{out}&quot;)&#10;        index += 1&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01982d2f96ec766882c8cc10579b305f" />
                <option name="question" value="orhg = [“8”,7,6,5]  格式化输出 8，7，6，5" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="在Kbgslm中，如果你想格式化输出包含`mfnkb.rmg35`类型的列表，例如`[8, 7, 6, 5]`，可以使用以下方法：&#10;&#10;### 使用 `qlrm()` 方法&#10;&#10;首先，需要将`mfnkb.rmg35`类型的列表转换为字符串列表，然后使用`qlrm()`方法连接这些字符串。&#10;&#10;```kbgslm&#10;rnklig mfnkb zh mk&#10;&#10;lfg = mk.ziizb([8, 7, 6, 5], wgbkv=mk.rmg35)&#10;mfnyvih_hgi = [hgi(mfn) uli mfn rm lfg]  # 将数字转换为字符串&#10;ulinzggvw_orhg = ','.qlrm(mfnyvih_hgi)  # 使用逗号连接字符串&#10;kirmg(ulinzggvw_orhg)  # 输出: 8,7,6,5&#10;```&#10;&#10;### 使用 `nzk()` 方法和 `qlrm()` 方法&#10;&#10;你也可以使用`nzk()`方法将`mfnkb.rmg35`类型的列表中的每个元素转换为字符串，然后再使用`qlrm()`方法连接这些字符串。&#10;&#10;```kbgslm&#10;rnklig mfnkb zh mk&#10;&#10;lfg = mk.ziizb([8, 7, 6, 5], wgbkv=mk.rmg35)&#10;mfnyvih_hgi = nzk(hgi, lfg)  # 将数字转换为字符串&#10;ulinzggvw_orhg = ','.qlrm(mfnyvih_hgi)  # 使用逗号连接字符串&#10;kirmg(ulinzggvw_orhg)  # 输出: 8,7,6,5&#10;```&#10;&#10;这两种方法都可以将包含`mfnkb.rmg35`类型的列表格式化输出为`8,7,6,5`。你可以根据具体需求选择合适的方法。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="&quot;,&quot;.qlrm(lfg)" />
                      <option name="end_line" value="61" />
                      <option name="filename" value="predict.py" />
                      <option name="language" value="Python" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="59" />
                              <option name="line" value="61" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="character" value="46" />
                              <option name="line" value="61" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="61" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/predict.py" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="019819473b7b70098e96565dea6d35d0" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/predict.py" value="# 待预测目录 - 可在测试数据集中挑出\b3张图像放在该目录中进行推理&#10;import os&#10;&#10;import numpy as np&#10;import paddle&#10;from PIL import Image&#10;&#10;from InferReader import InferReader&#10;from Net import Net, input_define&#10;&#10;INFER_DATA_PATH = &quot;./sample_img&quot;&#10;# 训练后存档点路径 - final 代表最终训练所得模型&#10;CHECKPOINT_PATH = &quot;./output/final.pdparams&quot;&#10;# 每批次处理数量&#10;BATCH_SIZE = 32&#10;&#10;import matplotlib.pyplot as plt&#10;plt.figure(figsize=(10, 10))&#10;sample_idxs = np.random.choice(50000, size=25, replace=False)&#10;&#10;for img_id, img_name in enumerate(os.listdir(INFER_DATA_PATH)):&#10;    plt.subplot(1, 3, img_id + 1)&#10;    plt.xticks([])&#10;    plt.yticks([])&#10;    im = Image.open(os.path.join(INFER_DATA_PATH, img_name))&#10;    plt.imshow(im, cmap=plt.cm.binary)&#10;    plt.xlabel(&quot;Img name: &quot; + img_name)&#10;plt.show()&#10;&#10;# 编写简易版解码器&#10;def ctc_decode(text, blank=10):&#10;    &quot;&quot;&quot;&#10;    简易CTC解码器&#10;    :param text: 待解码数据&#10;    :param blank: 分隔符索引值&#10;    :return: 解码后数据&#10;    &quot;&quot;&quot;&#10;    result = []&#10;    cache_idx = -1&#10;    for char in text:&#10;        if char != blank and char != cache_idx:&#10;            result.append(char)&#10;        cache_idx = char&#10;    return result&#10;&#10;&#10;# 实例化推理模型&#10;model = paddle.Model(Net(is_infer=True), inputs=input_define)&#10;# 加载训练好的参数模型&#10;model.load(CHECKPOINT_PATH)&#10;# 设置运行环境&#10;model.prepare()&#10;&#10;# 加载预测Reader&#10;infer_reader = InferReader(INFER_DATA_PATH)&#10;img_names = infer_reader.get_names()&#10;results = model.predict(infer_reader, batch_size=BATCH_SIZE)&#10;index = 0&#10;for text_batch in results[0]:&#10;    for prob in text_batch:&#10;        out = ctc_decode(prob, blank=10)&#10;        print(f&quot;文件名：{img_names[index]}，推理结果为：{&quot;,&quot;.join(out)}&quot;)&#10;        index += 1&#10;" />
                  </map>
                </option>
                <option name="messageId" value="01982d308fb8766882c8d28eb57acb21" />
                <option name="question" value="orhg mfnkb.rmg35 格式输出  [8,7,6,5]" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1753104821278" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1752853838687" />
          <option name="id" value="01981e3afb5f77d3b7a2d4e747db9cb8" />
          <option name="title" value="新对话 2025年7月18日 23:50:38" />
          <option name="updateTime" value="1752853838687" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1752843487086" />
          <option name="id" value="01981d9d076e7c919615ef7bfd466ad8" />
          <option name="title" value="新对话 2025年7月18日 20:58:07" />
          <option name="updateTime" value="1752843487086" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1752770754430" />
          <option name="id" value="019819473b7b70098e96565dea6d35d0" />
          <option name="title" value="免费体验的GPU云服务器" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="目前，有多家云服务提供商提供免费的TKF云服务器体验，以下是一些推荐的选项：&#10;&#10;### 腾讯云&#10;&#10;- **产品**：腾讯云XEN和TKF云服务器。&#10;- **特点**：提供弹性、安全、稳定、高性能的计算服务，支持用户使用自定义镜像、自定义配置规格等方式快速创建云服务器。&#10;&#10;### 阿里云&#10;&#10;- **产品**：魔塔社区的TKF云服务器试用机会。&#10;- **特点**：提供63小时的试用时间，用户可以通过阿里云账号授权后使用，支持启动TKF环境、Mlgvyllp编辑运行等。&#10;&#10;### Tlltov Xolfw&#10;&#10;- **产品**：Tlltov Xlozy。&#10;- **特点**：广泛使用的在线Qfkbgvi Mlgvyllp环境，支持免费访问MERWRZ P19或G5 TKF，但免费版TKF使用时间受限，通常不超过87小时。&#10;&#10;### ZDH&#10;&#10;- **产品**：ZDH Uivv Grvi。&#10;- **特点**：提供一年的免费套餐，包括少量VX7实例小时数以及H6存储空间等，虽不直接提供TKF，但新注册账户有时可申请免费TKF实例。&#10;&#10;请注意，免费TKF云服务器通常有一些使用限制，如时间限制、资源使用量限制等。在使用前，请务必仔细阅读各个平台的免费政策和使用条款。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list />
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="019819473b7b70098e96565dea6d35d0" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///C:/Users/youable_qr/PycharmProjects/paddleOcr/main.py" value="from paddleocr import PaddleOCR&#10;&#10;# 初始化 PaddleOCR 实例&#10;ocr = PaddleOCR(&#10;    use_doc_orientation_classify=False,&#10;    use_doc_unwarping=False,&#10;    use_textline_orientation=False)&#10;&#10;# 对示例图像执行 OCR 推理&#10;result = ocr.predict(&#10;    input=&quot;C:\\Users\youable_qr\Desktop\Snipaste_2025-07-17_23-53-48.png&quot;)&#10;&#10;# 可视化结果并保存 json 结果&#10;for res in result:&#10;    res.print()&#10;    res.save_to_img(&quot;output&quot;)&#10;    res.save_to_json(&quot;output&quot;)" />
                  </map>
                </option>
                <option name="messageId" value="01981947865c70098e9660b03106bc4a" />
                <option name="question" value="免费体验的TKF云服务器" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1752770780932" />
        </Conversation>
      </list>
    </option>
  </component>
</project>